package com.manuanand.clouddrive;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.Calendar;
import java.util.Date;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.server.ResponseStatusException;

@Controller	// This means that this class is a Controller
@RequestMapping(path="/user") // This means URL's start with /user (after Application path)
public class UserController {
	@Autowired // This means to get the bean called userRepository
			   // Which is auto-generated by Spring, we will use it to handle the data
	private UserRepository userRepository;

	@Autowired
	private FileRepository fileRepository;
	
	private static final char[] hexArray = "0123456789abcdef".toCharArray();
	///
	// User Repository
	///
	@PostMapping(path="/add") // Map ONLY POST Requests
	public @ResponseBody User addUser (
			@RequestParam String name, @RequestParam String email, 
			@RequestParam String password, @RequestParam (required = false) Boolean isPremiumCustomer) {

		User newUser = new User();
		newUser.setName(name);
		newUser.setEmail(email);
		newUser.setPassword(password);
		
		if (isPremiumCustomer != null) {
			newUser.setIsPremiumCustomer(isPremiumCustomer);
		} else {
			newUser.setIsPremiumCustomer(Boolean.FALSE);
		}
		
		userRepository.save(newUser);
		
		return newUser;
	}

	@GetMapping(path="/")
	public @ResponseBody Iterable<User> getAllUsers() {
		
		// This returns a JSON or XML with the users
		return userRepository.findAll();
	}

	@GetMapping(path="/{id}")
	public @ResponseBody User getSpecificUser(@PathVariable String id) {
		
		Integer userId = null;
		try {
			userId = Integer.parseInt(id);
		} catch (NumberFormatException ex) {
			return null;
		}

		Optional<User> user = userRepository.findById(userId);
		if (!user.isEmpty()) {
			return user.get();
		} 

		return null;
	}
	
	@PostMapping(path="/upload") // Map ONLY POST Requests
	public @ResponseBody File uploadFile (
			@RequestParam Integer userId, @RequestParam String password,
			@RequestParam String title, 
			@RequestParam String description, 
			@RequestParam String path,
			@RequestParam String contents) {
	
		// Validate user ID
		Optional<User> user = userRepository.findById(userId);
		if (user.isEmpty()) {
			throw new ResponseStatusException(
					  HttpStatus.NOT_FOUND, "User with ID" + userId + " not found");
		} else if (!user.get().getPassword().equals(password))  {
			throw new ResponseStatusException(
					  HttpStatus.INTERNAL_SERVER_ERROR, "Password mismatched for User ID" + userId);
		}
		
		File newFile = new File();
		newFile.setUserId(userId);
		newFile.setTitle(title);
		newFile.setDescription(description);
		newFile.setContents(contents);
		newFile.setPath(path);
		
		// Check if this is the first upload for this file and set version appropriately
		String remotePath = "/users/" + userId + "/" + path;
		
		// Check if this file exists
		Integer version = 1;
		Iterable<File> remoteFiles = fileRepository.findByUserIdAndRemotePath(userId, remotePath);
		if (remoteFiles.iterator().hasNext()) {
			// Get just the first file - This should have the highest version since query sorts them in desc order by version
			File remoteFile = remoteFiles.iterator().next();
			version = remoteFile.getVersion() + 1;
		} else {
			version = 1;
		}
	
		// Calculated fields - remotePath, md5sum, uploadDate, version
		newFile.setRemotePath(remotePath);
		newFile.setMd5Sum(getMd5(contents));
		newFile.setUploadDate(new Date());
		newFile.setVersion(version);
		newFile.setIsDeleted(Boolean.FALSE);
		
		fileRepository.save(newFile);
		
		return newFile;
	}
	
	public static String getMd5(String input)
    {
		try {
		   MessageDigest digester = MessageDigest.getInstance("MD5");
		    digester.update(input.getBytes());
		    byte[] md5Bytes = digester.digest();
		    String md5Text = null;

		    md5Text = bytesToHex(md5Bytes);

		    return md5Text;
		} catch (Exception e) {
            throw new RuntimeException(e);
        }
    } 
	    
	public static String bytesToHex(byte[] bytes) {
	        char[] hexChars = new char[bytes.length * 2];
	        for (int j = 0; j < bytes.length; j++) {
	            int v = bytes[j] & 0xFF;
	            hexChars[j * 2] = hexArray[v >>> 4];
	            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
	        }
	        return new String(hexChars);
	    }
  
}